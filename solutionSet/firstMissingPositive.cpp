#include<iostream>
#include<vector>

using namespace std;

/*

    给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
    请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解

    找出没有出现的最小正整数，时间复杂度要求，常数级别的而外空间

    翻译过来就是遍历一次，额外空间是固定的

    从1开始变大，注意对比，然后取最大值，但是，后面出现的中间数，无法包含

    但是，无论如何这个就是从头到尾遍历的，要不用双指针，那个啥方块法的

    比如说rear指针保证后面的都是可以排序成没有空隙的递增的一组数
    前面一个指针指向一个比rear指向的数大的数，保证中间有空隙，然后一个变量用来保存中间空隙的数量，但是这个有什么意义呢？

    比如说一种情况：两指针之间，已经遍历过 用于填充间隙 的数字，但是由于中间刚好缺失了那个数字，导致后指针迟迟不移动，现在这个数来了
    该怎么办？怎么移动到准确的位置？总之需要准确描述中间变量的东西

    是否需要像next数组那样的用来描述，这样不错，但之前那个心血来潮的用来描述中间空隙数量的变量呢，好像那个只能解决一些特殊的情况

    不如这样吧，生成一个等长的数组，数组用来存储含有间隙的数字，下标表示间隙的大小，但是怎么用来区分间隙和有没有区分填入数字数字呢
    可以把数组全部初始化为零，这样就可以了，因为符合条件的一定是大于零的正整数
    一个指针从头到尾往后遍历所给的数组，一个用来储存现在符合条件的最大的数是什么，每次一个指针遍历的时候和该数作比较，如果大于这个数求差值
    找到差值之后，在创建数组对应的地方放入这个数，如果第零个地方有数字，就把储存符合题意的数跟新为这个数，然后把

    等下，如果两个数组都有一个指针那怎么说，下面那个指针指向的是目前符合题意的数的标。那你可能会问，如果数组的数超过下面数组的长度了怎么
    办，但是如果超过长度了的话，这个就根本不可能会符合题意了
*/

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int length = nums.size();
        int *number = new int[length];
        for(int i = 0;i < length; i++)
        {
            number[i] = 0;
        }
        //初始化一个等长的数组并且把所有元素都变为零

        int below = 0;//储存符合题意的变量
        //整个指针p1,用来指向现在遍历的
        for(int p1 = 0;p1 < length;p1++)
        {
            if(below < nums[p1] && nums[p1] < length)//如果有一个数比目前的数字大,并且小于长度，那么就放入哈希中
            {
                number[nums[p1]] = 1;//将对应的数改为1

                while(number[below + 1] == 1)//判断在改变之后，below指向后的是否有数了，如果有的话就向后移动，直到后面没有为止
                {
                    below ++;
                }

            }
        }
        return below +1;

    }
};

int main()
{
    vector<int> v = {1};
    Solution s;
    cout<<s.firstMissingPositive(v);
    return 0;
}